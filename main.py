import logging
import traceback
import sqlite3
from typing import Dict, Any, Optional

from dotenv import load_dotenv

import telegram
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup, helpers
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackQueryHandler,
    Application
)
from telegram.constants import ParseMode
from telegram.error import TelegramError, Forbidden, BadRequest

import config
import database as db
import air_raid
import weather
import currency

load_dotenv()

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("bot.log", encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

try:
    config.load_config()
except ValueError as e:
    logger.critical(f"Configuration error: {e}")
    exit(1)

BOT_TOKEN = config.cfg.get('BOT_TOKEN')
ADMIN_IDS = [int(id_str) for id_str in config.cfg.get('ADMIN_IDS', '').split(',') if id_str.strip().isdigit()]
AIR_RAID_CHECK_INTERVAL = config.cfg.get('AIR_RAID_CHECK_INTERVAL', 90)

MAIN_MENU = [
    ["üîî –¢—Ä–µ–≤–æ–≥–∞", "üíµ –ö—É—Ä—Å –≤–∞–ª—é—Ç"],
    ["‚òÄÔ∏è –ü–æ–≥–æ–¥–∞"]
]
WEATHER_MENU = [
    ["üåÜ –ò–∑–º–µ–Ω–∏—Ç—å –≥–æ—Ä–æ–¥", "üîÑ –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–≥–Ω–æ–∑"],
    ["‚¨ÖÔ∏è –ù–∞–∑–∞–¥"]
]
CURRENCY_MENU = [
    ["üîÑ –û–±–Ω–æ–≤–∏—Ç—å –∫—É—Ä—Å", "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–æ–¥ –≤–∞–ª—é—Ç—ã"],
    ["‚¨ÖÔ∏è –ù–∞–∑–∞–¥"]
]
AIR_RAID_MENU = [
    ["üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å", "üåç –í—ã–±—Ä–∞—Ç—å –æ–±–ª–∞—Å—Ç—å"],
    ["‚¨ÖÔ∏è –ù–∞–∑–∞–¥"]
]

try:
    db.init_db()
except sqlite3.Error as e:
    logger.critical(f"Failed to initialize database: {e}")
    exit(1)

def require_message(func):
    async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
        if not update.message:
            logger.warning(f"{func.__name__} called without message")
            return
        try:
            return await func(update, context, *args, **kwargs)
        except Exception as e:
            await update.message.reply_text(f"‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞: {str(e)}")
            raise
    return wrapper

@require_message
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    user_id = user.id if user else "Unknown ID"
    first_name = helpers.escape_markdown(user.first_name, version=2) if user else "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á"
    logger.info(f"User {user_id} started the bot.")

    context.user_data['menu'] = 'main'
    reply_markup = ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)

    welcome_message = (
        f"–ü—Ä–∏–≤—ñ—Ç, {first_name}\\!\n\n"
        "–Ø —Ç–≤—ñ–π –ø–æ–º—ñ—á–Ω–∏–∫\\. –û–±–µ—Ä–∏ –¥—ñ—é –∑ –º–µ–Ω—é –Ω–∏–∂—á–µ:"
    )

    await update.message.reply_text(welcome_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN_V2)

@require_message
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id if update.effective_user else "Unknown ID"
    logger.info(f"User {user_id} requested help.")

    help_text = (
        "–û—Å—å —â–æ —è –≤–º—ñ—é:\n\n"
        "*–û—Å–Ω–æ–≤–Ω–µ –º–µ–Ω—é:*\n"
        "\\- üîî *–¢—Ä–µ–≤–æ–≥–∞*: –°—Ç–∞—Ç—É—Å —Ç—Ä–∏–≤–æ–≥ —Ç–∞ –ø—ñ–¥–ø–∏—Å–∫–∞\\.\n"
        "\\- üíµ *–ö—É—Ä—Å –≤–∞–ª—é—Ç*: –ö—É—Ä—Å –≤–∞–ª—é—Ç\\.\n"
        "\\- ‚òÄÔ∏è *–ü–æ–≥–æ–¥–∞*: –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ–≥–æ–¥–∏\\.\n\n"
        "*–ö–æ–º–∞–Ω–¥–∏:*\n"
        "`/start` \\- –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–æ –º–µ–Ω—é\\.\n"
        "`/help` \\- –î–æ–ø–æ–º–æ–≥–∞\\.\n"
        "`/subscribe` \\- –ü—ñ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Ç—Ä–∏–≤–æ–≥–∏\\.\n"
        "`/unsubscribe` \\- –í—ñ–¥–ø–∏—Å–∫–∞\\.\n"
        "`/status` \\- –°—Ç–∞—Ç—É—Å –ø—ñ–¥–ø–∏—Å–∫–∏\\."
    )

    await update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN_V2)

async def resolve_region_id(region_name: str) -> Optional[str]:
    alerts = await air_raid.get_air_raid_status()
    if not alerts:
        return None
    for region in alerts:
        if region.get('regionName', '').lower() == region_name.lower():
            return region.get('regionId')
    return None

@require_message
async def subscribe(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id if update.effective_user else None
    if not user_id:
        return

    region = " ".join(context.args).strip() if context.args else None
    if region:
        region_id = await resolve_region_id(region)
        if not region_id:
            await update.message.reply_text("–†–µ–≥—ñ–æ–Ω –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")
            return
        if db.is_subscribed(user_id, region_id):
            await update.message.reply_text(f"–í–∏ –≤–∂–µ –ø—ñ–¥–ø–∏—Å–∞–Ω—ñ –Ω–∞ {region}.")
        elif db.add_subscriber(user_id, region_id):
            await update.message.reply_text(f"–ü—ñ–¥–ø–∏—Å–∞–Ω–æ –Ω–∞ {region}.")
        else:
            await update.message.reply_text("–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–ø–∏—Å–∫–∏.")
        return

    alerts = await air_raid.get_air_raid_status()
    if not alerts:
        await update.message.reply_text("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Å–ø–∏—Å–æ–∫ —Ä–µ–≥—ñ–æ–Ω—ñ–≤.")
        return

    keyboard = [
        [InlineKeyboardButton(region.get('regionName'), callback_data=f"subscribe:{region.get('regionId')}")]
        for region in sorted(alerts, key=lambda x: x.get('regionName', ''))
    ]
    keyboard.append([InlineKeyboardButton("–í—Å—ñ —Ä–µ–≥—ñ–æ–Ω–∏", callback_data="subscribe:all")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("–û–±–µ—Ä—ñ—Ç—å —Ä–µ–≥—ñ–æ–Ω –¥–ª—è –ø—ñ–¥–ø–∏—Å–∫–∏:", reply_markup=reply_markup)

@require_message
async def unsubscribe(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id if update.effective_user else None
    if not user_id:
        return

    region = " ".join(context.args).strip() if context.args else None
    if region:
        region_id = await resolve_region_id(region)
        if not region_id:
            await update.message.reply_text("–†–µ–≥—ñ–æ–Ω –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
            return
        if not db.is_subscribed(user_id, region_id):
            await update.message.reply_text(f"–í–∏ –Ω–µ –ø—ñ–¥–ø–∏—Å–∞–Ω—ñ –Ω–∞ {region}.")
        elif db.remove_subscriber(user_id, region_id):
            await update.message.reply_text(f"–í—ñ–¥–ø–∏—Å–∞–Ω–æ –≤—ñ–¥ {region}.")
        else:
            await update.message.reply_text("–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø–∏—Å–∫–∏.")
        return

    if not db.is_subscribed(user_id):
        await update.message.reply_text("–í–∏ –Ω–µ –ø—ñ–¥–ø–∏—Å–∞–Ω—ñ.")
    elif db.remove_subscriber(user_id):
        await update.message.reply_text("–í—ñ–¥–ø–∏—Å–∞–Ω–æ –≤—ñ–¥ —É—Å—ñ—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å.")
    else:
        await update.message.reply_text("–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø–∏—Å–∫–∏.")

@require_message
async def status(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id if update.effective_user else None
    if not user_id:
        return

    subscriptions = db.get_subscribers()
    user_regions = [r for u, r in subscriptions if u == user_id]
    if not user_regions:
        await update.message.reply_text("–í–∏ –Ω–µ –ø—ñ–¥–ø–∏—Å–∞–Ω—ñ.")
        return

    alerts = await air_raid.get_air_raid_status()
    region_names = {r.get('regionId'): r.get('regionName') for r in alerts} if alerts else {}
    message = "–í–∏ –ø—ñ–¥–ø–∏—Å–∞–Ω—ñ –Ω–∞:\n"
    for region_id in user_regions:
        name = region_names.get(region_id, "–í—Å—ñ —Ä–µ–≥—ñ–æ–Ω–∏" if region_id is None else "–ù–µ–≤—ñ–¥–æ–º–∏–π —Ä–µ–≥—ñ–æ–Ω")
        message += f"- {name}\n"
    await update.message.reply_text(message)

@require_message
async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id if update.effective_user else None
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ.")
        return

    sub_count = len(set(u for u, _ in db.get_subscribers()))
    await update.message.reply_text(f"–ö—ñ–ª—å–∫—ñ—Å—Ç—å –ø—ñ–¥–ø–∏—Å–Ω–∏–∫—ñ–≤: {sub_count}")

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not update.message or not update.message.text:
        return

    text = update.message.text
    user_id = update.effective_user.id if update.effective_user else "Unknown ID"
    logger.info(f"Received text from {user_id}: '{text}'")

    try:
        if text == "üîî –¢—Ä–µ–≤–æ–≥–∞":
            context.user_data['menu'] = 'air_raid'
            reply_markup = ReplyKeyboardMarkup(AIR_RAID_MENU, resize_keyboard=True)
            await update.message.reply_text("–ú–µ–Ω—é —Ç—Ä–∏–≤–æ–≥:", reply_markup=reply_markup)
        elif text == "üíµ –ö—É—Ä—Å –≤–∞–ª—é—Ç":
            context.user_data['menu'] = 'currency'
            reply_markup = ReplyKeyboardMarkup(CURRENCY_MENU, resize_keyboard=True)
            await update.message.reply_text("–ú–µ–Ω—é –≤–∞–ª—é—Ç:", reply_markup=reply_markup)
            await currency.get_currency_command(update, context)
        elif text == "‚òÄÔ∏è –ü–æ–≥–æ–¥–∞":
            context.user_data['menu'] = 'weather'
            reply_markup = ReplyKeyboardMarkup(WEATHER_MENU, resize_keyboard=True)
            await update.message.reply_text("–ú–µ–Ω—é –ø–æ–≥–æ–¥–∏:", reply_markup=reply_markup)
            await weather.get_weather_command(update, context)

        elif context.user_data.get('menu') == 'weather':
            if text == "üåÜ –ò–∑–º–µ–Ω–∏—Ç—å –≥–æ—Ä–æ–¥":
                await update.message.reply_text("–í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –º—ñ—Å—Ç–∞:")
                context.user_data['awaiting_city'] = True
            elif text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–≥–Ω–æ–∑":
                context.args = [context.user_data.get('city', 'Kyiv')]
                await weather.get_weather_command(update, context, force_update=True)
            elif text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
                context.user_data['menu'] = 'main'
                reply_markup = ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)
                await update.message.reply_text("–ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–æ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é:", reply_markup=reply_markup)

        elif context.user_data.get('menu') == 'currency':
            if text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å –∫—É—Ä—Å":
                await currency.get_currency_command(update, context, force_update=True)
            elif text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–æ–¥ –≤–∞–ª—é—Ç—ã":
                await update.message.reply_text("–í–≤–µ–¥—ñ—Ç—å –∫–æ–¥ –≤–∞–ª—é—Ç–∏ \\(–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, USD, EUR\\):", parse_mode=ParseMode.MARKDOWN_V2)
                context.user_data['awaiting_currency'] = True
            elif text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
                context.user_data['menu'] = 'main'
                reply_markup = ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)
                await update.message.reply_text("–ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–æ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é:", reply_markup=reply_markup)

        elif context.user_data.get('menu') == 'air_raid':
            if text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å":
                await air_raid.alerts_command(update, context)
            elif text == "üåç –í—ã–±—Ä–∞—Ç—å –æ–±–ª–∞—Å—Ç—å":
                alerts = await air_raid.get_air_raid_status()
                if not alerts:
                    await update.message.reply_text("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Å–ø–∏—Å–æ–∫ —Ä–µ–≥—ñ–æ–Ω—ñ–≤.")
                    return
                keyboard = [
                    [InlineKeyboardButton(region.get('regionName'), callback_data=f"region:{region.get('regionId')}")]
                    for region in sorted(alerts, key=lambda x: x.get('regionName', ''))
                ]
                keyboard.append([InlineKeyboardButton("–í—Å—ñ —Ä–µ–≥—ñ–æ–Ω–∏", callback_data="region:all")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text("–û–±–µ—Ä—ñ—Ç—å –æ–±–ª–∞—Å—Ç—å:", reply_markup=reply_markup)
            elif text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
                context.user_data['menu'] = 'main'
                reply_markup = ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)
                await update.message.reply_text("–ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–æ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é:", reply_markup=reply_markup)

        elif context.user_data.get('awaiting_city'):
            context.user_data['city'] = text
            context.user_data['awaiting_city'] = False
            context.args = [text]
            await weather.get_weather_command(update, context)
        
        elif context.user_data.get('awaiting_currency'):
            currency_code = text.upper()
            context.user_data['awaiting_currency'] = False
            if currency.add_currency_code(user_id, currency_code):
                await update.message.reply_text(f"–î–æ–¥–∞–Ω–æ –≤–∞–ª—é—Ç—É {currency_code}.")
                await currency.get_currency_command(update, context)
            else:
                await update.message.reply_text("–ù–µ–≤—ñ—Ä–Ω–∏–π –∫–æ–¥ –≤–∞–ª—é—Ç–∏ –∞–±–æ –ø–æ–º–∏–ª–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è.")
    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞: {str(e)}")
        raise

async def button_callback(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    action, data = query.data.split(':')

    try:
        if action == "subscribe":
            region_id = None if data == 'all' else data
            if db.is_subscribed(user_id, region_id):
                await query.message.reply_text("–í–∏ –≤–∂–µ –ø—ñ–¥–ø–∏—Å–∞–Ω—ñ –Ω–∞ —Ü–µ–π —Ä–µ–≥—ñ–æ–Ω.")
                return
            if db.add_subscriber(user_id, region_id):
                alerts = await air_raid.get_air_raid_status()
                region_name = next(
                    (r.get('regionName') for r in alerts if r.get('regionId') == region_id),
                    '–≤—Å—ñ —Ä–µ–≥—ñ–æ–Ω–∏'
                ) if alerts else '–≤—Å—ñ —Ä–µ–≥—ñ–æ–Ω–∏'
                await query.message.reply_text(f"–ü—ñ–¥–ø–∏—Å–∞–Ω–æ –Ω–∞ {region_name}.")
            else:
                await query.message.reply_text("–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–ø–∏—Å–∫–∏.")
        
        elif action == "region":
            region_id = None if data == 'all' else data
            context.user_data['selected_region'] = region_id
            alerts = await air_raid.get_air_raid_status()
            region_name = next(
                (r.get('regionName') for r in alerts if r.get('regionId') == region_id),
                '–≤—Å—ñ —Ä–µ–≥—ñ–æ–Ω–∏'
            ) if alerts else '–≤—Å—ñ —Ä–µ–≥—ñ–æ–Ω–∏'
            await query.message.reply_text(f"–û–±—Ä–∞–Ω–æ –æ–±–ª–∞—Å—Ç—å: {region_name}. –¢—Ä–∏–≤–æ–≥–∏ –±—É–¥—É—Ç—å –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏—Å—è –ª–∏—à–µ –¥–ª—è –Ω–µ—ó.")
            await air_raid.alerts_command(update, context)
    except Exception as e:
        await query.message.reply_text(f"‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞: {str(e)}")
        raise

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    if context.error is None:
        logger.warning(f"Error handler called without error. Update: {update}")
        return

    logger.error("Exception occurred:", exc_info=context.error)
    tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
    tb_string = "".join(tb_list)

    chat_id = update.effective_chat.id if isinstance(update, Update) and update.effective_chat else None
    if chat_id:
        error_message = f"‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞: {str(context.error)}"
        await context.bot.send_message(chat_id=chat_id, text=error_message)

async def cleanup_subscribers(context: ContextTypes.DEFAULT_TYPE) -> None:
    subscribers = db.get_subscribers()
    for user_id, _ in set((u, r) for u, r in subscribers):
        try:
            await context.bot.send_chat_action(chat_id=user_id, action='typing')
        except telegram.error.Forbidden:
            db.remove_subscriber(user_id)
            logger.info(f"Removed inactive subscriber {user_id}")

def main():
    logger.info("Starting bot...")
    application = ApplicationBuilder().token(BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("subscribe", subscribe))
    application.add_handler(CommandHandler("unsubscribe", unsubscribe))
    application.add_handler(CommandHandler("status", status))
    application.add_handler(CommandHandler("admin", admin_command))
    application.add_handler(CommandHandler("weather", weather.get_weather_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))
    application.add_handler(CallbackQueryHandler(button_callback))
    application.add_error_handler(error_handler)

    job_queue = application.job_queue
    if job_queue:
        try:
            interval = int(AIR_RAID_CHECK_INTERVAL)
            if interval <= 0:
                interval = 90
                logger.warning("Invalid AIR_RAID_CHECK_INTERVAL. Using default: 90.")
            job_queue.run_repeating(air_raid.check_air_raid_status, interval=interval, first=10)
            job_queue.run_repeating(cleanup_subscribers, interval=604800, first=86400)
        except (ValueError, TypeError):
            logger.error("Invalid AIR_RAID_CHECK_INTERVAL. Using default: 90.")
            job_queue.run_repeating(air_raid.check_air_raid_status, interval=90, first=10)

    logger.info("Bot is running...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()